### 请求报文
####  起始行
  
由三部分组成：<method><url><version>  
1、请求方法，GET、POST等  
2、请求URL  
3、HTTP协议版本 HTTP/X.X

####  首部
  
请求头部只在请求报文中有意义，说明了发送请求的信息包括请求者能力以便服务器更好响应，由关键字/值对组成，每行一对，常用的首部如下：
|键|值|
|----|----|
|User-Agent|请求的浏览器类型|
|Accept |客户端希望接受的数据类型，如text/xml（application/json）表示希望接受到的是xml（json）类型|
|Content-Type|发送端发送的实体数据的数据类型，纯文本text/plain；普通表单默认格式application/x-www-form-urlencoded，form表单数据被编码为key/value格式发送到服务器；multipart/form-data，用以支持向服务器发送二进制数据，以便可以在 POST 请求中实现文件上传等功能|
|Host |请求的主机名|
   
首部是以一个空行结束的

####  主体

主体是http报文的负荷，就是http要传输的内容，通常根据首部Content-Type来决定主体内容，该项为可选项

### 响应报文
####  起始行

由三部分组成：<version><status-code><Reason-Phrase>  
1、HTTP协议版本 HTTP/X.X  
2、响应状态码 XXX  
3、状态短语  
####  首部
  
响应报文有自己的首部，为客户端提供了一些额外的信息，如发生响应者的功能、与响应有关的特殊指令，有助于客户端处理响应，响应头部与请求一样由关键字/值对组成，每行一对，常用的首部如下：
|键|值|
|----|----|
|Public|服务器为资源支持的请求方法列表|
|Server |服务器应用软件的名称和版本|
|Content-Type|发送端发送的实体数据的数据类型，纯文本text/plain；普通表单默认格式application/x-www-form-urlencoded，form表单数据被编码为key/value格式发送到服务器；multipart/form-data，用以支持向服务器发送二进制数据，以便可以在 POST 请求中实现文件上传等功能|
####  主体
与请求报文一致

### 首部分类
可以发现有一些首部其实是共通的，还有一些是可以按照功能来归类的，所以首部可以按类别来分，以下列举了一些常用的如下：

#### 通用首部

|键|值|
|----|----|
|Connect|服务器为资源支持的请求方法列表|
|Date |提供日期和时间标识说明报文是什么时候创建的|
|Update|给出了发送端可能想要升级新版本和协议|
|Cache-Control|用于随报文传送缓存指示|

#### 条件请求首部
客户端希望加上一些限制
|键|值|
|----|----|
|Expect|允许客户端列出某请求要求服务器的行为|
|If-Range |允许对文档某个范围进行条件搜索|

#### 安全请求首部
Http本身就支持一种简单的机制，可以对请求进行质询/响应认证，这种机制要求客户端在获取指定资源时需要对自身进行认证
|键|值|
|----|----|
|Authorization|保护客户端提供给服务器，以便对其自身进行认证的数据|
|Cookie |客户端用来向服务器传送一个令牌|
|Cookie2 |用来说明请求端支持的cookie版本，已废弃|

#### 代理请求首部
Http本身就支持一种简单的机制，可以对请求进行质询/响应认证，这种机制要求客户端在获取指定资源时需要对自身进行认证
|键|值|
|----|----|
|Proxy-Authorization|与Authorization相同，但是是在与代理进行认证时使用的|
|Proxy-Connection |同上|

#### 协商首部
服务器和客户端提供对资源进行协商的能力
|键|值|
|----|----|
|Accept-Ranges|对此资源来说，服务器可接受的范围|
|Vary|服务器查看其它首部的列表，可能使响应发生变化|

#### 安全响应首部
与安全请求首部对应，提供
|键|值|
|----|----|
|Proxy-Authenticate|来自代理对客户端的质询列表|
|Set-Cookie|可以在客户端设置一个令牌，以便服务器对客户端进行标识|
|Set-Cookie2|与Set-Cookie类似，RFC2965 cookie定义，已废弃|
|WWW-Authenticate|来自服务器对客户端的质询列表|

#### 实体首部
实体首部提供描述http报文负荷，由于请求和响应报文中可能包含实体的部分，实体首部提供了很多有关实体的信息，告诉报文接受者如何处理
|键|值|
|----|----|
|Allow|列出对此实体执行的请求方法|
|Location|告知客户端实体上位于何处，将接收端定向到资源的url上去|


#### 重点
关于Connection和Keep-Alive  
HTTP1.0要显式指明1.1之后就不需要了，Keep-Alive顾名思义保活，对HTTP事务处理结束后Tcp连接保持在打开的情况，以便后续http请求重用现存连接，即持久连接。  
对于发出keepalive请求之后，客户端和服务器不一定会同意进行keepalive回话，它们可以在任意时间关闭空闲的keepalive连接。
Keep-Alive首部支持参数timeout服务器希望保持活跃时间和max服务器希望为多少事务保持此连接活跃状态
Connection 承接3种标签 http首部列出与此连接有关的首部， 值close是否关闭持久连接，任意值描述此连接非标准选项。
对于一些没法处理处理Connection首部的代理则会出现哑代理的情况，这些盲中继是无法处理keepalive连接的第二条请求，这些请求将会被挂起  
解决方法是添加Proxy-Connection首部, 非盲中继情况下会转发Connection，盲中继情况下发这个首部被服务器忽略，这对单个盲中继修复但是多个还是存在问题  
   
一、什么是HTTP管线化？
通常，HTTP请求总是顺序发送的，下一个请求只有在当前请求的响应被完全接受的时候才会被发送。由于网络延迟和带宽的限制，这样会导致在服务器发送下一个响应的时候中间有很大的延迟。  
HTTP/1.1允许多个HTTP请求通过一个套接字同时被输出 ，而不用等待相应的响应。然后请求者就会等待各自的响应，这些响应是按照之前请求的顺序依次到达。  
只有幂等的请求才可以被管线化，比如GET和HEAD。POST和PUT不应该被管线化。我们同样也不应该在建立新连接的时候发出管线化的请求 ，因为不能确源服务或代理是否支持HTTP/1.1。因此，管线化只能利用已存在的keep-alive连接。

### 总结
可以看出首部几乎把报文的信息都进行了描述和说明，对接受端处理和要求，所有报文首部的处理来说对http学习以及运用是十分重要的  
  
具体http首部可以参考mdn<https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers>